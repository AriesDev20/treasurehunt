<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arrow Pointer — Stable Center Rotation</title>
  <style>
    :root{--bg:#071029; --card:#0f1724; --accent1:#ff6b6b; --accent2:#ffd166; --muted:rgba(255,255,255,0.6)}
    *{box-sizing:border-box}
    body{margin:0;min-height:100vh;font-family:system-ui,Inter,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071029 0%,#07121a 100%);color:#fff;display:flex;align-items:center;justify-content:center;padding:28px}
    .wrap{width:100%;max-width:720px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:18px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
    h1{margin:0 0 8px 0;font-size:18px}
    .subtitle{color:var(--muted);font-size:13px;margin-bottom:14px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:14px}
    input[type=number]{padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#fff;min-width:140px}
    button{padding:10px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
    .btn-primary{background:linear-gradient(90deg,var(--accent1),var(--accent2));color:#111;box-shadow:0 6px 18px rgba(255,100,100,0.12)}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:#fff}
    .visual{display:flex;align-items:center;gap:22px}
    .arrow-box{width:260px;height:260px;border-radius:16px;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.00));border:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center}

    /* Rotator contains rotation only; scaler contains pulse scaling only */
    .rotator{width:140px;height:200px;display:flex;align-items:center;justify-content:center;transform:rotate(var(--rot,0deg));transition:transform 250ms cubic-bezier(.2,.9,.2,1);transform-origin:center center}
    .scaler{display:inline-block;transition:transform 180ms ease;transform-origin:center center}

    /* pulse animation (applied to .scaler when in direction) */
    .scaler.pulse{animation:pulseScale 900ms infinite}
    @keyframes pulseScale{0%{transform:scale(1)}50%{transform:scale(1.14)}100%{transform:scale(1)}}

    .arrow-svg{width:140px;height:200px;display:block}

    .stats{display:flex;flex-direction:column;gap:10px}
    .stat{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-width:160px}
    .muted{color:var(--muted);font-size:13px}
    .tiny{font-size:12px;color:var(--muted)}
    @media(max-width:640px){.visual{flex-direction:column}.arrow-box{width:220px;height:220px}.rotator{width:120px;height:170px}.arrow-svg{width:120px;height:170px}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Arrow Pointer — Center Rotation</h1>
      <div class="subtitle">Arrow rotates smoothly around its visual center. Pulses and vibrates when you're facing the target.</div>

      <div class="controls">
        <input id="targetLat" type="number" step="any" placeholder="Latitude (e.g. 1.3521)">
        <input id="targetLon" type="number" step="any" placeholder="Longitude (e.g. 103.8198)">
        <button id="setTarget" class="btn-primary">Point</button>
        <label style="display:flex;align-items:center;gap:8px;margin-left:auto;color:var(--muted)"><input id="vibToggle" type="checkbox"> Vibration</label>
      </div>

      <div class="visual">
        <div class="arrow-box" aria-hidden="false">
          <!-- rotator applies rotation only, scaler applies scaling/pulse only -->
          <div class="rotator" id="rotator" style="--rot:0deg">
            <div class="scaler" id="scaler">
              <svg class="arrow-svg" viewBox="0 0 120 180" xmlns="http://www.w3.org/2000/svg" aria-hidden="false">
                <defs>
                  <linearGradient id="gradHead" x1="0" x2="1"><stop offset="0" stop-color="#ff6b6b"/><stop offset="1" stop-color="#ffd166"/></linearGradient>
                  <filter id="s" x="-50%" y="-50%" width="200%" height="200%"><feDropShadow dx="0" dy="10" stdDeviation="12" flood-color="#000" flood-opacity="0.45"/></filter>
                </defs>
                <!-- Head (points up at 0deg) -->
                <path d="M60 8 L96 56 L60 48 L24 56 Z" fill="url(#gradHead)" filter="url(#s)" />
                <!-- shaft -->
                <rect x="54" y="48" width="12" height="90" rx="6" ry="6" fill="rgba(255,255,255,0.06)" />
                <rect x="62" y="52" width="4" height="82" rx="2" ry="2" fill="rgba(255,255,255,0.12)" />
                <!-- center dot -->
                <circle cx="60" cy="90" r="6" fill="#fff" />
              </svg>
            </div>
          </div>
        </div>

        <div class="stats">
          <div class="stat"><div class="muted">Bearing</div><strong id="bearingVal">—°</strong></div>
          <div class="stat"><div class="muted">Device heading</div><strong id="headingVal">—°</strong></div>
          <div class="stat"><div class="muted">Distance</div><strong id="distanceVal">—</strong></div>
          <div class="tiny">Threshold: <input id="threshold" type="range" min="5" max="45" value="18"> <span id="thresholdVal">18</span>°</div>
          <div class="tiny" id="note">Tip: Grant Motion & Orientation permission on iOS for heading + vibration.</div>
        </div>
      </div>
    </div>
  </div>

<script>
const toRad = d => d * Math.PI / 180;
const toDeg = r => r * 180 / Math.PI;
function computeBearing(lat1, lon1, lat2, lon2){
  const φ1 = toRad(lat1), φ2 = toRad(lat2);
  const Δλ = toRad(lon2 - lon1);
  const y = Math.sin(Δλ) * Math.cos(φ2);
  const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
  let θ = Math.atan2(y,x); θ = (toDeg(θ) + 360) % 360; return θ;
}
function haversineDistance(lat1, lon1, lat2, lon2){
  const R = 6371e3; const φ1 = toRad(lat1), φ2 = toRad(lat2);
  const Δφ = toRad(lat2 - lat1), Δλ = toRad(lon2 - lon1);
  const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2; const c = 2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); return R * c;
}
function shortestAngleDiff(a,b){ return Math.abs((a - b + 540) % 360 - 180); }

const rotator = document.getElementById('rotator');
const scaler = document.getElementById('scaler');
const bearingEl = document.getElementById('bearingVal');
const headingEl = document.getElementById('headingVal');
const distanceEl = document.getElementById('distanceVal');
const setTargetBtn = document.getElementById('setTarget');
const targetLatInput = document.getElementById('targetLat');
const targetLonInput = document.getElementById('targetLon');
const vibToggle = document.getElementById('vibToggle');
const thresholdInput = document.getElementById('threshold');
const thresholdVal = document.getElementById('thresholdVal');

let currentPos = null; let targetPos = null; let watchId = null; let latestHeading = null; let haveHeading = false; let lastInDirection=false; let vibCooldown=false;

thresholdInput.addEventListener('input', ()=> thresholdVal.textContent = thresholdInput.value);

function setRotation(deg){ rotator.style.setProperty('--rot', deg + 'deg'); }
function setPulse(on){ if(on) scaler.classList.add('pulse'); else scaler.classList.remove('pulse'); }

function updateUI(){
  if(!currentPos || !targetPos) return;
  const bearing = computeBearing(currentPos.latitude, currentPos.longitude, targetPos.lat, targetPos.lon);
  const dist = haversineDistance(currentPos.latitude, currentPos.longitude, targetPos.lat, targetPos.lon);
  bearingEl.textContent = bearing.toFixed(1) + '°';
  distanceEl.textContent = dist >= 1000 ? (dist/1000).toFixed(2) + ' km' : Math.round(dist) + ' m';

  if(haveHeading && latestHeading != null){
    const angleDiff = (bearing - latestHeading + 360) % 360; // rotation relative to device facing
    setRotation(angleDiff);
    headingEl.textContent = latestHeading.toFixed(1) + '°';

    const diff = shortestAngleDiff(latestHeading, bearing);
    const th = parseFloat(thresholdInput.value);
    const inDirection = diff <= th;
    if(inDirection && !lastInDirection){ // just entered
      if(vibToggle.checked && navigator.vibrate && !vibCooldown){ navigator.vibrate([60,30,60]); vibCooldown=true; setTimeout(()=>vibCooldown=false,1200); }
    }
    setPulse(inDirection);
    lastInDirection = inDirection;
  } else {
    setRotation(bearing);
    headingEl.textContent = 'N/A';
    setPulse(false);
    lastInDirection = false;
  }
}

setTargetBtn.addEventListener('click', ()=>{
  const lat = parseFloat(targetLatInput.value); const lon = parseFloat(targetLonInput.value);
  if(!isFinite(lat) || !isFinite(lon)){ alert('Enter valid coordinates'); return; }
  targetPos = {lat, lon};
  if(navigator.geolocation && !currentPos){ navigator.geolocation.getCurrentPosition(p=>{ currentPos = p.coords; updateUI(); }, e=>{ console.warn(e); }, {enableHighAccuracy:true, timeout:10000}); }
  updateUI();
});

// tracking button (simple)
const startBtn = document.createElement('button'); startBtn.id='startTrack'; startBtn.className='btn-ghost'; startBtn.textContent='Start tracking'; startBtn.addEventListener('click', ()=>{
  if(watchId!=null){ navigator.geolocation.clearWatch(watchId); watchId=null; startBtn.textContent='Start tracking'; return; }
  if(!navigator.geolocation){ alert('Geolocation unavailable'); return; }
  watchId = navigator.geolocation.watchPosition(pos=>{ currentPos = pos.coords; if(targetPos) updateUI(); }, err=>{ alert('Error: '+err.message); }, {enableHighAccuracy:true, maximumAge:2000, timeout:10000});
  startBtn.textContent='Stop tracking';
});
// attach to controls
document.querySelector('.controls').appendChild(startBtn);

// device orientation listener
function onDeviceOrientation(e){ let heading=null; if(typeof e.webkitCompassHeading === 'number') heading = e.webkitCompassHeading; else if(typeof e.alpha === 'number') heading = (360 - e.alpha) % 360; if(heading!=null){ latestHeading = heading; haveHeading = true; if(targetPos && currentPos) updateUI(); } }

async function enableHeading(){ if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){ try{ const perm = await DeviceOrientationEvent.requestPermission(); if(perm==='granted'){ window.addEventListener('deviceorientation', onDeviceOrientation); document.getElementById('note').textContent='Heading enabled — point your device toward the treasure.'; } else alert('Permission denied for motion/orientation'); }catch(err){ alert('Error requesting permission: '+err); } } else { window.addEventListener('deviceorientation', onDeviceOrientation); document.getElementById('note').textContent='Heading enabled (if supported).'; } }

// add small enable heading button
const enableBtn = document.createElement('button'); enableBtn.className='btn-ghost'; enableBtn.textContent='Enable heading'; enableBtn.addEventListener('click', enableHeading); document.querySelector('.controls').appendChild(enableBtn);

window.addEventListener('deviceorientation', onDeviceOrientation);

[targetLatInput, targetLonInput].forEach(inp=> inp.addEventListener('keydown', e=>{ if(e.key==='Enter') setTargetBtn.click(); }));

// initial
setRotation(0);
</script>
</body>
</html>
